{
  "transpiled": true,
  "noir_version": "1.0.0-beta.0+b3f4ad661c8c6f88544d714fd5b7b6f58a8ce4ad-aarch64",
  "name": "Crowdfunding",
  "functions": [
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 7,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "donate",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "pack_arguments_oracle_wrapper",
        "random",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "get_random_bytes",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "_publish_donation_receipts",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14313802839798733697": {
            "error_kind": "string",
            "string": "Function _publish_donation_receipts can only be called internally"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBFJgAABAMmAgMEAiYCBAQAHxgABAADgEMdAIBDgEMFLQiAQwABLQiARAACJAAAAE0nAgABBIBFJgICBAA6DQABAAIkAAACTx4CAAQAHgIABQAyOAAEAAUABiYCBAEBIwIABgAAAHYkAAACeB4CAAQBHgIABQAKOAQFBiMCAAYAAACSJAAAAoocDAEEACYCAQAALAgBBSYCBgQEABABBgEmAwUEAQAoBQIGLAwGBywOAQcAKAcCBywOAQcAKAcCBywOAQcoAgABAGIkMgMsCAEGJgIHBAQAEAEHASYDBgQBACgGAgcsDAcILA4ECAAoCAIILA4CCAAoCAIILA4BCCwNBQEAKAECASwOAQUsCAEBAAABAgEsDgUBJgICBAMmAgQEACYCBQQBLAwEAyIAAAE7DDgDAgQjAgAEAAABxSIAAAFNLA0BAyYCBQQDBigFAgEmAgcEAwA4BQcGLAgBBAAQAQYBJgMEBAEAKAQCBiwOBQYAKAYCBiwOBQYmAgcEAwA4BAcGACgDAgctBAAHgAMtBAAGgAQtBAAFgAUkAAACnAAoBAIGLA0GBSYCBwQCADgGBwM2DQADAAUlJgIHBAMMOAMHCCMCAAgAAAHcJAAAAuIAKAYCBwA4BwMILA0IBCwNAQcmAgkEAww4AwkKIwIACgAAAgUkAAAC4i0EAAeAAycAgAQEAAQkAAAC9C0IgAUACAAoCAIJADgJAwosDgQKADgDBQQOOAMEByMCAAcAAAJCJAAAA4IsDggBLAwEAyIAAAE7JwCABAR4AA0AAACABIADIwCAAwAAAncpAQABBfeh86+lrdTKOwEBAiUpAQABBb4eP/8+pPb6OwEBAiUpAQABBcak19hTLluBOwEBAiUBAIADgAWABy0AgAOACC0AgASACQsAgAiAB4AKIwCACgAAAuEtAYAIgAYtAoAGgAkBAIAIAAKACAEAgAkAAoAJIgAAArAlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAADDyIAAAMaLQCAA4AFIgAAA4EtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAADbS0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAADPCcBgAUEAAEDAIAGAAKABiIAAAOBJSkBAAEFRafKcRlB5BU7AQECJS0AGMoYyg==",
      "debug_symbols": "7ZzhTuMwDMffpZ/7IY6dxOFVTggNKGjStKExTjoh3v1aWLq2q5o71tEk7RdEkdv+/YsbJ07Ie/ZY3L893623T7vX7ObXe7bZPawO6922vHr/yLP7/XqzWT/fNf+cieoHy0/715fVtrp8Paz2h+wGtBV5Vmwfy1+NEOUTntabIrvR8iM/NxZCOWMhVW0MZHqsCZmP1oTW1NZMPcYM6B7NoKBpfJtnbEbQztIZl+J/TrsdgztBzV37uINCpx2UpWHtVkr3aCs1dbSXDT6qeBBt8Z+vUFd/BeD1X8EXv4KUQhdzSoMn5qRw4cwSTLfd5OUej/gJgPxfOtVNiN+4ieA7N+m+m5CAjjchKR6mZYSDZUAPm7LQdcs1+iHRZyu1izpptMdWswsfI7DrooJQXURhnATBLdtP3cE2zbBuLSLVreLUbSLlbSLlzZHyZopUN8ep22Kkuk2UustRYaS6g83zSjoJStkz3RBs/+3RbePULYPtvz26I+WNkfLGSHlTsPnSozvYfDmsWwWbLz26I82XOtg6hEd3uHm+LtNp8JWI2LhyEtuTbW9FD01dGEaDJyCS7ReQcDvYaYCYcDPlRECCnbJOBITDzTUTAQl30DAJEAx4NnklIOWbnWss8QwIhjscvhIQC04DWuwBktgnYxtrqV+LhUiJdZN9LqbfigFPrEZzMf1WDHi6NpqL4c6kx3LRpN+KJv1WDHfJdTwXExv/9rmYWN2kx0VL6buYfCuSSL4VCZLvUQmSz4skk59pkExjpqFE7SI3XTw3tSRrW1K6ywPTaPLxeKTxlY/Gg9KY8IzHY4mPFg81u7Iyq3rhgRuuHcvKpbcLkBYQvURIG0hqNaTLgSQ2sr4YCC8R0gGyREgbiE1svv0PQGy9msuN/6GsgdCyvN0GMrtdZcNAVGpVuIuBwOw2UfmAzG4TlQeIXPYMtYHg7NKuD8jsttl5gCRSLxsRyOyG7h4g4Z4fMRWQpQ9pAwn3xIupgCwR0gZiloFZB8jsqu5DQD7Ky9+r/Xp1vymOp9k9vW0fGofbHf68FJ1z7l72u4fi8W1fVCfenQ67q/oiIMhByxJ0FXcgTQ5obqsTx6pLUDlIUV1WmQ00lraq1FDq+As=",
      "brillig_names": [
        "_publish_donation_receipts"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14313802839798733697": {
            "error_kind": "string",
            "string": "Function _publish_donation_receipts can only be called internally"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "withdraw",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2646186389125283523": {
            "error_kind": "string",
            "string": "Only the operator can withdraw funds"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "txs_effects_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "txs_effects_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "pack_arguments_oracle_wrapper",
        "call_private_function_internal",
        "enqueue_public_function_call_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VUyw6CMBBseURBOaiJ3kz8gyIYOJJ49x8akKMe8OKNT5eabbqpVRKlJkzSbEs3szNlW0oUKESPvAH9tGnIFdhBDCA6aN/tRgFr9hviQKs7JH/O0iQw+BtQ/5OfWtIvIPktnT+bAM+xVfzYi6w77UaIesKWZ/nPbHpe9fhc/MFnh32k1caghm+uIYci3RuYR4Y8iRlRd9prh/eV5YzJei7w++RVO67va/lrWIeafvmOFV/qrDMe1wmv+YFXVVrypcYv4KBzGnMvbGHe1wvY45yo3mjul/J0vZ0b0gNB8gCVxsvQjgYAAA==",
      "debug_symbols": "nZJLCoMwFEX38sYOzMdP3IoUiRolEBKJsVDEvTeKLbY4SSYPbrjnTnJW6EW7jI3Ug5mhqldQpuNOGu3TuiXQWqmUHJvrM6T7QejozxPXe5wdtw4qghMQuoeKpp4epBJQ5Xh7JIBwYJ8E9mlgPwvr49t9Rlh+Eoxi8mVQyg4oi4HyGKiIgcoIiNx+PKNl9oGylP5Cm49PbiVvlTjFGhbdXTxzr0n8KTdZ04l+sWKX7+KdvzUqEoz9rJ9+Aw==",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "init",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "donation_token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "operator",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "deadline",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "init"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000000c0c5aaf"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000003de78269"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Crowdfunding"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "donation_token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "operator",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "deadline",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "donation_reciept_notes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "amount",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            },
            {
              "name": "who",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "Crowdfunding::WithdrawalProcessed"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Crowdfunding::_publish_donation_receipts_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Crowdfunding::_publish_donation_receipts_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "donation_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "operator",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "deadline",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Crowdfunding::init_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Crowdfunding::init_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Crowdfunding::withdraw_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Crowdfunding::withdraw_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Crowdfunding::donate_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Crowdfunding::donate_abi"
        }
      ]
    }
  },
  "file_map": {
    "102": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr",
      "source": "use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n"
    },
    "106": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "107": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "108": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "109": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_app_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_app_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivpsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_app_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_app_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getAppTaggingSecretAsSender)]\nunconstrained fn get_app_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "111": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "112": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "113": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr",
      "source": "/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"
    },
    "118": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "119": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "125": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must be large enough to hold all of\n/// the elements past `offset`.\n///\n/// Example:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n/// ```\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "128": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "142": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"
    },
    "147": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "148": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "149": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/generators.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// A set of generators generated with `derive_generators(...)` function from noir::std\npub global Ga1: Point = Point {\n    x: 0x30426e64aee30e998c13c8ceecda3a77807dbead52bc2f3bf0eae851b4b710c1,\n    y: 0x113156a068f603023240c96b4da5474667db3b8711c521c748212a15bc034ea6,\n    is_infinite: false,\n};\npub global Ga2: Point = Point {\n    x: 0x2825c79cc6a5cbbeef7d6a8f1b6a12b312aa338440aefeb4396148c89147c049,\n    y: 0x129bfd1da54b7062d6b544e7e36b90736350f6fba01228c41c72099509f5701e,\n    is_infinite: false,\n};\npub global Ga3: Point = Point {\n    x: 0x0edb1e293c3ce91bfc04e3ceaa50d2c541fa9d091c72eb403efb1cfa2cb3357f,\n    y: 0x1341d675fa030ece3113ad53ca34fd13b19b6e9762046734f414824c4d6ade35,\n    is_infinite: false,\n};\npub global Ga4: Point = Point {\n    x: 0x0e0dad2250583f2a9f0acb04ededf1701b85b0393cae753fe7e14b88af81cb52,\n    y: 0x0973b02c5caac339ee4ad5dab51329920f7bf1b6a07e1dabe5df67040b300962,\n    is_infinite: false,\n};\npub global Ga5: Point = Point {\n    x: 0x2f3342e900e8c488a28931aae68970738fdc68afde2910de7b320c00c902087d,\n    y: 0x1bf958dc63cb09d59230603a0269ae86d6f92494da244910351f1132df20fc08,\n    is_infinite: false,\n};\n// If you change this update `G_SLOT` in `yarn-project/simulator/src/client/test_utils.ts` as well\npub global G_slot: Point = Point {\n    x: 0x041223147b680850dc82e8a55a952d4df20256fe0593d949a9541ca00f0abf15,\n    y: 0x0a8c72e60d0e60f5d804549d48f3044d06140b98ed717a9b532af630c1530791,\n    is_infinite: false,\n};\n\nmod test {\n    use crate::generators::{G_slot, Ga1, Ga2, Ga3, Ga4, Ga5};\n    use dep::protocol_types::point::Point;\n    use std::hash::derive_generators;\n\n    #[test]\n    unconstrained fn test_generators() {\n        let generators: [Point; 6] = derive_generators(\"aztec_nr_generators\".as_bytes(), 0);\n        assert_eq(generators[0], Ga1);\n        assert_eq(generators[1], Ga2);\n        assert_eq(generators[2], Ga3);\n        assert_eq(generators[4], Ga4);\n        assert_eq(generators[5], Ga5);\n        assert_eq(generators[3], G_slot);\n    }\n}\n"
    },
    "152": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "153": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr",
      "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "168": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "170": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest,\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::{Deserialize, Serialize},\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "204": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "211": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "240": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash([self.secret, recipient.to_field(), self.index as Field])\n    }\n}\n"
    },
    "251": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "266": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "267": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "283": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "289": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "293": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "300": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "301": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "302": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::scoped::Scoped,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::{arrays::array_concat, field::field_from_bytes};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    tx_hash: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage())\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "303": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "306": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::IndexedTreeLeafPreimage,\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "312": {
      "path": "/Users/ankit.agrawal/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "319": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-contracts/contracts/router_contract/src/utils.nr",
      "source": "use crate::Router;\nuse aztec::context::private_context::PrivateContext;\nuse aztec::protocol_types::constants::ROUTER_ADDRESS;\n\n// docs:start:helper_router_functions\n/// Asserts that the current timestamp in the enqueued public call enqueued by `check_timestamp` satisfies\n/// the `operation` with respect to the `value. Preserves privacy by performing the check via the router contract.\n/// This conceals an address of the calling contract by setting `context.msg_sender` to the router contract address.\npub fn privately_check_timestamp(operation: u8, value: u64, context: &mut PrivateContext) {\n    Router::at(ROUTER_ADDRESS).check_timestamp(operation, value).call(context);\n}\n\n/// Asserts that the current block number in the enqueued public call enqueued by `check_block_number` satisfies\n/// the `operation` with respect to the `value. Preserves privacy by performing the check via the router contract.\n/// This conceals an address of the calling contract by setting `context.msg_sender` to the router contract address.\npub fn privately_check_block_number(operation: u8, value: Field, context: &mut PrivateContext) {\n    // docs:start:enqueueing\n    Router::at(ROUTER_ADDRESS).check_block_number(operation, value).call(context);\n    // docs:end:enqueueing\n}\n// docs:end:helper_router_functions\n"
    },
    "320": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-contracts/contracts/router_contract/src/main.nr",
      "source": "mod test;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n/// The purpose of this contract is to perform a check in public without revealing what contract enqued the public\n/// call. This is achieved by having a private function on this contract that enques the public call and hence\n/// the `msg_sender` in the public call is the address of this contract.\n#[aztec]\ncontract Router {\n    use aztec::{macros::functions::{internal, private, public, view}, utils::comparison::compare};\n\n    // docs:start:check_timestamp\n    /// Asserts that the current timestamp in the enqueued public call satisfies the `operation` with respect\n    /// to the `value.\n    #[private]\n    fn check_timestamp(operation: u8, value: u64) {\n        Router::at(context.this_address())._check_timestamp(operation, value).enqueue_view(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    #[view]\n    fn _check_timestamp(operation: u8, value: u64) {\n        let lhs_field = context.timestamp() as Field;\n        let rhs_field = value as Field;\n        assert(compare(lhs_field, operation, rhs_field), \"Timestamp mismatch.\");\n    }\n    // docs:end:check_timestamp\n\n    /// Asserts that the current block number in the enqueued public call satisfies the `operation` with respect\n    /// to the `value.\n    #[private]\n    fn check_block_number(operation: u8, value: Field) {\n        Router::at(context.this_address())._check_block_number(operation, value).enqueue_view(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    #[view]\n    fn _check_block_number(operation: u8, value: Field) {\n        assert(compare(context.block_number(), operation, value), \"Block number mismatch.\");\n    }\n}\n"
    },
    "336": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr",
      "source": "// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::{\n            encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n            encrypted_note_emission::encode_and_encrypt_note_unconstrained,\n        },\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n    };\n\n    use dep::uint_note::uint_note::UintNote;\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::balance_set::BalanceSet;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: PublicImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_to_public\n    #[public]\n    fn mint_to_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_to_public\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_in_public\n\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        // TODO: constrain encryption below - we are using unconstrained here only because of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from,\n            from,\n        ));\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_in_private`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(&mut context, to, from),\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:burn_private\n    #[private]\n    fn burn_private(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // TODO: constrain encryption below - we are using unconstrained here only becuase of the following Noir issue\n        // https://github.com/noir-lang/noir/issues/5771\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note_unconstrained(&mut context, from, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn_private\n\n    // docs:start:transfer_to_private\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    #[private]\n    fn transfer_to_private(to: AztecAddress, amount: Field) {\n        // `from` is the owner of the public balance from which we'll subtract the `amount`.\n        let from = context.msg_sender();\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_private\n\n    // docs:start:prepare_private_balance_increase\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_to_private`, `finalize_mint_to_private`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n    // docs:end:prepare_private_balance_increase\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = UintNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let setup_log = note_setup_payload.encrypt_log(context, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // docs:start:finalize_transfer_to_private\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_to_private(amount: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // TODO(#8271): Type the amount as U128 and nuke the ugly cast\n        let amount = U128::from_integer(amount);\n\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:mint_to_private\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueud call).\n    #[private]\n    fn mint_to_private(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        amount: Field,\n    ) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_to_private_unsafe(context.msg_sender(), amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n    // docs:end:mint_to_private\n\n    // docs:start:finalize_mint_to_private\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_to_public`\n    /// and `finalize_transfer_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_to_private(amount: Field, hiding_point_slot: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private\n\n    // docs:start:finalize_mint_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_mint_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_to_private` function.\n        assert(storage.minters.at(from).read(), \"caller is not minter\");\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_mint_to_private(\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let amount = U128::from_integer(amount);\n\n        // First we increase the total supply by the `amount`\n        let supply = storage.total_supply.read().add(amount);\n        storage.total_supply.write(supply);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n        nonce: Field, // A nonce to make authwitness unique.\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            user,\n            user,\n        ));\n\n        // 4. We prepare the partial notes\n        let fee_payer_point_slot =\n            _prepare_private_balance_increase(user, fee_payer, &mut context, storage);\n        let user_point_slot = _prepare_private_balance_increase(user, user, &mut context, storage);\n\n        // 5. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime { FunctionSelector::from_signature(\"complete_refund(Field,Field,Field)\") },\n            [fee_payer_point_slot, user_point_slot, funded_amount],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_slot: Field, user_slot: Field, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, fee_payer_slot, tx_fee);\n        let user_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, user_slot, refund_amount);\n\n        // 4. At last we emit the note hashes and the final note logs.\n        fee_payer_finalization_payload.emit();\n        user_finalization_payload.emit();\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"
    },
    "350": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "355": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "62": {
      "path": "/Users/ankit.agrawal/projects/block-c/noir/crowdfunding/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Crowdfunding {\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public},\n            storage::storage,\n        },\n        prelude::{AztecAddress, PrivateSet, PublicImmutable},\n        protocol_types::traits::Serialize,\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n        utils::comparison::Comparator,\n    };\n    use std::meta::derive;\n    use dep::value_note::value_note::ValueNote;\n    use router::utils::privately_check_timestamp;\n    use token::Token;\n\n    #[derive(Serialize)]\n    #[event]\n    struct WithdrawalProcessed {\n        amount: u64,\n        who: AztecAddress,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        // Token used for donations\n        donation_token: PublicImmutable<AztecAddress, Context>,\n        // Crowd funding operator\n        operator: PublicImmutable<AztecAddress, Context>,\n        // Deadline for the crowd funding\n        deadline: PublicImmutable<u64, Context>,\n        // donation reciept notes\n        donation_reciept_notes: PrivateSet<ValueNote, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(donation_token: AztecAddress, operator: AztecAddress, deadline: u64) {\n        storage.donation_token.initialize(donation_token);\n        storage.operator.initialize(operator);\n        storage.deadline.initialize(deadline);\n    }\n\n    #[private]\n    fn donate(amount: u64){\n        // 1) Check that the deadline has not passed --> we do that via the router contract to conceal which contract\n        // is performing the check.\n        let deadline = storage.deadline.read();\n        privately_check_timestamp(Comparator.LT, deadline, &mut context);\n        // 2) Transfer the donation token from the sender to the contract\n        let donor = context.msg_sender();\n        Token::at(storage.donation_token.read())\n            .transfer_in_private(donor, context.this_address(), amount as Field, 0)\n            .call(&mut context);\n        // 3) Create a value note for the donor so that he can later on claim a rewards token in the Claim\n        // contract by proving that the hash of this note exists in the note hash tree.\n        let mut note = ValueNote::new(amount as Field, donor);\n\n        storage.donation_reciept_notes.insert(&mut note).emit(encode_and_encrypt_note\n        (&mut context, donor, donor));\n    }\n\n    // Withdraws balance to the operator. Requires that msg_sender() is the operator.\n    #[private]\n    fn withdraw(amount: u64) {\n        // 1) check that message sender is the operator\n        let operator_address = storage.operator.read();\n        assert(context.msg_sender() == operator_address, \"Only the operator can withdraw funds\");\n\n        // 2) Transfer the donation token from the contract to the operator\n        Token::at(storage.donation_token.read())\n        .transfer(operator_address, amount as Field)\n        .call(&mut context);\n\n        // 3) Emit an unencrypted event so that anyone can audit how much the operator has withdrawn\n        Crowdfunding::at(context.this_address())\n        ._publish_donation_receipts(amount, operator_address)\n        .enqueue(&mut context);\n\n    }\n\n    #[public]\n    #[internal]\n    fn _publish_donation_receipts(amount: u64, to: AztecAddress) {\n        WithdrawalProcessed { amount, who: to }.emit(encode_event(&mut context));\n    }\n}"
    },
    "68": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "69": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "74": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "78": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr",
      "source": "use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"
    },
    "82": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::arguments::pack_arguments;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "84": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "85": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        key_validation_request::get_key_validation_request,\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert(request.pk_m.hash() == pk_m_hash);\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // The oracle simulates the private call and returns the value of the side effects counter after execution of\n        // the call (which means that end_side_effect_counter - start_side_effect_counter is the number of side effects\n        // that took place), along with the hash of the return values. We validate these by requesting a private kernel\n        // iteration in which the return values are constrained to hash to `returns_hash` and the side effects counter\n        // to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "89": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "90": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Unconstrained logs have both their content and encryption unconstrained - it could occur that the\n        // recipient is unable to decrypt the payload.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        //   It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "92": {
      "path": "/Users/ankit.agrawal/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.67.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::poseidon2_hash,\n    point::Point,\n    public_keys::AddressPoint,\n    scalar::Scalar,\n    utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    field::bn254::decompose, hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    // We assume that the sender wants for the recipient to find the tagged note, and therefore that they will cooperate\n    // and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the note\n    // automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getAppTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"
    }
  }
}
